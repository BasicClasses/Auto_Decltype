# Auto и Decltype
 
**auto** — тип выводится из инициализатора (похоже на вывод шаблонного параметра). \
**decltype(expr)** — инспекция типа выражения (включая категорию значения: lvalue/xvalue/prvalue). \
**decltype(auto)** — вывод делает по правилам decltype, а не auto. 
  
## auto: базовые примеры
```
auto a = 10;      // int
auto b = 3.14;    // double
auto p = &a;      // int*
```
тип берётся из выражения справа, auto — “заглушка” под тип 

auto “по умолчанию по значению”: теряет ссылку и top‑level const
```
int i = 5;
int& ri = i;
const int ci = 7;

auto x = ri;  // int   (ссылка потерялась)
auto y = ci;  // int   (top-level const снялся)
```
вывод типа auto следует правилам, аналогичным выводу шаблонного параметра — по значению ссылки/верхний const обычно не сохраняются без явных &/const 
 
Как “сохранить” ссылку/константность: auto&, const auto&
```
int i = 5;
const int ci = 7;

auto  a  = i;      // int (копия)
auto& b  = i;      // int& (ссылка)
const auto& c = ci; // const int& (частый паттерн)
```

## decltype возвращает тип сущности/выражения

decltype(e) — это оператор для инспекции типа: возвращает тип сущности или тип+категорию значения выражения

```
int x = 10;

decltype(x)   a = x;  // int
decltype((x)) b = x;  // int&  (ВАЖНО!)
```
decltype(x) (без скобок) — “имя сущности”, берётся объявленный тип; decltype((x)) — уже lvalue‑выражение → ссылка 
 
### Где нужен decltype: тип результата выражения и trailing return type
```
template<class T, class U>
auto add(T t, U u) -> decltype(t + u) {
    return t + u;
}
```
decltype(t + u) позволяет получить тип выражения t + u на этапе компиляции

decltype(auto): “как decltype, но вывод из инициализатора/return”

### decltype(auto): “как decltype, но вывод из инициализатора/return”
```
int& get_ref(int& x) { return x; }

auto bad(int& x) {         // вернёт int (копия)
    return get_ref(x);
}

decltype(auto) good(int& x) { // вернёт int& (ссылка)
    return get_ref(x);
}
```
decltype(auto) позволяет “идеально” сохранить ссылочность результата 

### Используй auto

 - Это локальная переменная, и тип очевидно следует из инициализатора (особенно итераторы/результаты фабрик/шаблонные типы).
 - Ты не обязан сохранять ссылочность и не хочешь случайных ссылок. (auto безопаснее в этом смысле.)
 - Ты хранишь лямбду (тип неименуем).

### Используй decltype
 - Ты пишешь шаблонный код, где тип нужно получить от выражения, но без инициализации этим выражением (типы-алиасы, метафункции).
 - Нужен trailing return type вида auto f(...) -> decltype(expr)
 - Ты осознанно работаешь с категориями значений и хочешь точность (T, T& ).


 
